// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/sSmok/ya-shortener/internal/repository.LinkRepository -o link_repository_minimock.go -n LinkRepositoryMock -p mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// LinkRepositoryMock implements mm_repository.LinkRepository
type LinkRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(url string) (s1 string, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(url string)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mLinkRepositoryMockCreate

	funcGet          func(short string) (s1 string, err error)
	funcGetOrigin    string
	inspectFuncGet   func(short string)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mLinkRepositoryMockGet
}

// NewLinkRepositoryMock returns a mock for mm_repository.LinkRepository
func NewLinkRepositoryMock(t minimock.Tester) *LinkRepositoryMock {
	m := &LinkRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mLinkRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*LinkRepositoryMockCreateParams{}

	m.GetMock = mLinkRepositoryMockGet{mock: m}
	m.GetMock.callArgs = []*LinkRepositoryMockGetParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mLinkRepositoryMockCreate struct {
	optional           bool
	mock               *LinkRepositoryMock
	defaultExpectation *LinkRepositoryMockCreateExpectation
	expectations       []*LinkRepositoryMockCreateExpectation

	callArgs []*LinkRepositoryMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LinkRepositoryMockCreateExpectation specifies expectation struct of the LinkRepository.Create
type LinkRepositoryMockCreateExpectation struct {
	mock               *LinkRepositoryMock
	params             *LinkRepositoryMockCreateParams
	paramPtrs          *LinkRepositoryMockCreateParamPtrs
	expectationOrigins LinkRepositoryMockCreateExpectationOrigins
	results            *LinkRepositoryMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// LinkRepositoryMockCreateParams contains parameters of the LinkRepository.Create
type LinkRepositoryMockCreateParams struct {
	url string
}

// LinkRepositoryMockCreateParamPtrs contains pointers to parameters of the LinkRepository.Create
type LinkRepositoryMockCreateParamPtrs struct {
	url *string
}

// LinkRepositoryMockCreateResults contains results of the LinkRepository.Create
type LinkRepositoryMockCreateResults struct {
	s1  string
	err error
}

// LinkRepositoryMockCreateOrigins contains origins of expectations of the LinkRepository.Create
type LinkRepositoryMockCreateExpectationOrigins struct {
	origin    string
	originUrl string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mLinkRepositoryMockCreate) Optional() *mLinkRepositoryMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for LinkRepository.Create
func (mmCreate *mLinkRepositoryMockCreate) Expect(url string) *mLinkRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("LinkRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &LinkRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("LinkRepositoryMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &LinkRepositoryMockCreateParams{url}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectUrlParam1 sets up expected param url for LinkRepository.Create
func (mmCreate *mLinkRepositoryMockCreate) ExpectUrlParam1(url string) *mLinkRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("LinkRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &LinkRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("LinkRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &LinkRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.url = &url
	mmCreate.defaultExpectation.expectationOrigins.originUrl = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the LinkRepository.Create
func (mmCreate *mLinkRepositoryMockCreate) Inspect(f func(url string)) *mLinkRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for LinkRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by LinkRepository.Create
func (mmCreate *mLinkRepositoryMockCreate) Return(s1 string, err error) *LinkRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("LinkRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &LinkRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &LinkRepositoryMockCreateResults{s1, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the LinkRepository.Create method
func (mmCreate *mLinkRepositoryMockCreate) Set(f func(url string) (s1 string, err error)) *LinkRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the LinkRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the LinkRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the LinkRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mLinkRepositoryMockCreate) When(url string) *LinkRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("LinkRepositoryMock.Create mock is already set by Set")
	}

	expectation := &LinkRepositoryMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &LinkRepositoryMockCreateParams{url},
		expectationOrigins: LinkRepositoryMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up LinkRepository.Create return parameters for the expectation previously defined by the When method
func (e *LinkRepositoryMockCreateExpectation) Then(s1 string, err error) *LinkRepositoryMock {
	e.results = &LinkRepositoryMockCreateResults{s1, err}
	return e.mock
}

// Times sets number of times LinkRepository.Create should be invoked
func (mmCreate *mLinkRepositoryMockCreate) Times(n uint64) *mLinkRepositoryMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of LinkRepositoryMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mLinkRepositoryMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_repository.LinkRepository
func (mmCreate *LinkRepositoryMock) Create(url string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(url)
	}

	mm_params := LinkRepositoryMockCreateParams{url}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := LinkRepositoryMockCreateParams{url}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.url != nil && !minimock.Equal(*mm_want_ptrs.url, mm_got.url) {
				mmCreate.t.Errorf("LinkRepositoryMock.Create got unexpected parameter url, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originUrl, *mm_want_ptrs.url, mm_got.url, minimock.Diff(*mm_want_ptrs.url, mm_got.url))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("LinkRepositoryMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the LinkRepositoryMock.Create")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(url)
	}
	mmCreate.t.Fatalf("Unexpected call to LinkRepositoryMock.Create. %v", url)
	return
}

// CreateAfterCounter returns a count of finished LinkRepositoryMock.Create invocations
func (mmCreate *LinkRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of LinkRepositoryMock.Create invocations
func (mmCreate *LinkRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to LinkRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mLinkRepositoryMockCreate) Calls() []*LinkRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*LinkRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *LinkRepositoryMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *LinkRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LinkRepositoryMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LinkRepositoryMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LinkRepositoryMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to LinkRepositoryMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to LinkRepositoryMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mLinkRepositoryMockGet struct {
	optional           bool
	mock               *LinkRepositoryMock
	defaultExpectation *LinkRepositoryMockGetExpectation
	expectations       []*LinkRepositoryMockGetExpectation

	callArgs []*LinkRepositoryMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LinkRepositoryMockGetExpectation specifies expectation struct of the LinkRepository.Get
type LinkRepositoryMockGetExpectation struct {
	mock               *LinkRepositoryMock
	params             *LinkRepositoryMockGetParams
	paramPtrs          *LinkRepositoryMockGetParamPtrs
	expectationOrigins LinkRepositoryMockGetExpectationOrigins
	results            *LinkRepositoryMockGetResults
	returnOrigin       string
	Counter            uint64
}

// LinkRepositoryMockGetParams contains parameters of the LinkRepository.Get
type LinkRepositoryMockGetParams struct {
	short string
}

// LinkRepositoryMockGetParamPtrs contains pointers to parameters of the LinkRepository.Get
type LinkRepositoryMockGetParamPtrs struct {
	short *string
}

// LinkRepositoryMockGetResults contains results of the LinkRepository.Get
type LinkRepositoryMockGetResults struct {
	s1  string
	err error
}

// LinkRepositoryMockGetOrigins contains origins of expectations of the LinkRepository.Get
type LinkRepositoryMockGetExpectationOrigins struct {
	origin      string
	originShort string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mLinkRepositoryMockGet) Optional() *mLinkRepositoryMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for LinkRepository.Get
func (mmGet *mLinkRepositoryMockGet) Expect(short string) *mLinkRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("LinkRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &LinkRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("LinkRepositoryMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &LinkRepositoryMockGetParams{short}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectShortParam1 sets up expected param short for LinkRepository.Get
func (mmGet *mLinkRepositoryMockGet) ExpectShortParam1(short string) *mLinkRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("LinkRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &LinkRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("LinkRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &LinkRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.short = &short
	mmGet.defaultExpectation.expectationOrigins.originShort = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the LinkRepository.Get
func (mmGet *mLinkRepositoryMockGet) Inspect(f func(short string)) *mLinkRepositoryMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for LinkRepositoryMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by LinkRepository.Get
func (mmGet *mLinkRepositoryMockGet) Return(s1 string, err error) *LinkRepositoryMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("LinkRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &LinkRepositoryMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &LinkRepositoryMockGetResults{s1, err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the LinkRepository.Get method
func (mmGet *mLinkRepositoryMockGet) Set(f func(short string) (s1 string, err error)) *LinkRepositoryMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the LinkRepository.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the LinkRepository.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the LinkRepository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mLinkRepositoryMockGet) When(short string) *LinkRepositoryMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("LinkRepositoryMock.Get mock is already set by Set")
	}

	expectation := &LinkRepositoryMockGetExpectation{
		mock:               mmGet.mock,
		params:             &LinkRepositoryMockGetParams{short},
		expectationOrigins: LinkRepositoryMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up LinkRepository.Get return parameters for the expectation previously defined by the When method
func (e *LinkRepositoryMockGetExpectation) Then(s1 string, err error) *LinkRepositoryMock {
	e.results = &LinkRepositoryMockGetResults{s1, err}
	return e.mock
}

// Times sets number of times LinkRepository.Get should be invoked
func (mmGet *mLinkRepositoryMockGet) Times(n uint64) *mLinkRepositoryMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of LinkRepositoryMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mLinkRepositoryMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_repository.LinkRepository
func (mmGet *LinkRepositoryMock) Get(short string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(short)
	}

	mm_params := LinkRepositoryMockGetParams{short}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := LinkRepositoryMockGetParams{short}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.short != nil && !minimock.Equal(*mm_want_ptrs.short, mm_got.short) {
				mmGet.t.Errorf("LinkRepositoryMock.Get got unexpected parameter short, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originShort, *mm_want_ptrs.short, mm_got.short, minimock.Diff(*mm_want_ptrs.short, mm_got.short))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("LinkRepositoryMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the LinkRepositoryMock.Get")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(short)
	}
	mmGet.t.Fatalf("Unexpected call to LinkRepositoryMock.Get. %v", short)
	return
}

// GetAfterCounter returns a count of finished LinkRepositoryMock.Get invocations
func (mmGet *LinkRepositoryMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of LinkRepositoryMock.Get invocations
func (mmGet *LinkRepositoryMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to LinkRepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mLinkRepositoryMockGet) Calls() []*LinkRepositoryMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*LinkRepositoryMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *LinkRepositoryMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *LinkRepositoryMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LinkRepositoryMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LinkRepositoryMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LinkRepositoryMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to LinkRepositoryMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to LinkRepositoryMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LinkRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockGetInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LinkRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LinkRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockGetDone()
}
